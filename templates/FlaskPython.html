<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="generator" content="Aspose.Words for .NET 22.3.0" /><title></title><style type="text/css">body { font-family:Calibri; font-size:11pt }h1, h2, p { margin:0pt 0pt 8pt }li { margin-top:0pt; margin-bottom:8pt }h1 { margin-top:12pt; margin-bottom:3pt; page-break-after:avoid; font-family:Arial; font-size:16pt; font-weight:bold }h2 { margin-top:12pt; margin-bottom:3pt; page-break-after:avoid; font-family:Arial; font-size:14pt; font-weight:bold; font-style:italic }.FencedCode { margin-bottom:8pt; font-family:Consolas; font-size:10pt; background-color:#e2e2e2 }.FencedCodebash { margin-bottom:8pt; font-family:Consolas; font-size:10pt; background-color:#e2e2e2 }.FencedCodehtml { margin-bottom:8pt; font-family:Consolas; font-size:10pt; background-color:#e2e2e2 }.FencedCodejavaScript { margin-bottom:8pt; font-family:Consolas; font-size:10pt; background-color:#e2e2e2 }.FencedCodejson { margin-bottom:8pt; font-family:Consolas; font-size:10pt; background-color:#e2e2e2 }.FencedCodepython { margin-bottom:8pt; font-family:Consolas; font-size:10pt; background-color:#e2e2e2 }.Quote { margin-bottom:8pt; border-left:2.25pt solid #9f9f9f; font-size:11pt; font-style:italic; color:#000000 }span.Hyperlink { text-decoration:underline; color:#0000ff }span.QuoteChar { font-size:12pt; font-style:italic; color:#000000 }</style></head><body><div><h1><span style="font-weight:normal">FLASK CON PYTHON</span></h1><p><span style="font-weight:bold">Universidad de Python en UDEMY</span></p><p><span>Se utiliza para hacer aplicaciones con Python.</span><br /><span>Framework aplicaciones de tipo rest o web.</span><br /><span>DJANGO ya trae muchos componentes ya integrados no como flask que todo lo maneja a través de extensiones.</span></p><h2><span style="font-weight:normal; font-style:normal">1. </span><span style="font-style:normal">INSTALACION</span></h2><p><span>Proceso de instalación </span><a href="https://flask.palletsprojects.com/en/2.1.x/" style="text-decoration:none"><span class="Hyperlink">Página web de FLASK</span></a><span>.</span><br /><span>Vamos a ver para instalar Flask en MAC en un entorno virtualizado por consola:</span></p><p class="FencedCodebash"><span>mkdir myProject </span><br /><span>cd myProyect </span><br /><span>python3 -m venv venv</span><br /><br /><span>source venv/bin/activate</span><br /><br /><span>pip install flask</span></p><p><span>Pero aquí lo vamos a hacer con Visual Studio Code.</span></p><h2><span style="font-weight:normal; font-style:normal">2. </span><span style="font-style:normal">COMENZANDO CON FLASK</span></h2><p><span>Miramos </span><a href="https://flask.palletsprojects.com/en/2.1.x/quickstart/" style="text-decoration:none"><span class="Hyperlink">la documentación de Flask</span></a><span> y lo primero que nos explica es para ponerlo en funcionamiento.</span></p><p class="FencedCodepython"><span>from flask import Flask</span><br /><br /><span>app = Flask(__name__)</span><br /><br /><span>@app.route("/")</span><br /><span>def hello_world():</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return "&lt;p&gt;Hello, World!&lt;/p&gt;"</span></p><p><span>Importamos la clase de Flask, el primer argumento es el nombre de la aplicación que en mi caso lo estoy haciendo en el archivo app.py, creamos una instacia de la clase Flask siendo (__name) que se necesita para que flask sepa donde buscar recursos y templates.</span><br /><span>app.route es el decorador que le dice a flask que url debería usar en cada función.</span><br /><span>Mientras en nuestra consola:</span></p><p class="FencedCodebash"><span>$ python -m flask</span><br /><span>$ export FLASK_APP=app.py</span><br /><span>$ export FLASK_ENV=development</span><br /><span>$ flask run</span></p><p style="margin-left:36pt; text-indent:-18pt; -aw-import:list-item; -aw-list-level-number:0; -aw-list-number-format:'*'; -aw-list-number-styles:'bullet'; -aw-list-padding-sml:11.4pt"><span style="-aw-import:ignore"><span><span style="font-family:'Courier New'">*</span></span><span style="width:11.4pt; font:7pt 'Times New Roman'; display:inline-block; -aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span></span><span>Running on http://127.0.0.1:5000/</span></p><p class="FencedCode"><span>Si vamos a la aplicación en la web pordemos ver nuestro Hello World.</span><br /><span>## 3. **LOGGING**</span><br /><span>Algunas veces puedes querer comprobar si todo va correctamente, puede que tengas algún código del lado del cliente que envíe una solicitud HTTP al servidor, pero obviamente está malformada.</span><br /><span>Esto puede deberse a que un usuario manipule los datos o a que falle el código del cliente. La mayoría de las veces está bien responder con 400 malas solicitudes en esa situación, etc para eso estan los loggers, que los mensajes salen por la terminal.</span><br /><span>```python</span><br /><span>@app.route("/")</span><br /><span>def inicio():</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>app.logger.debug("Mensaje a nivel debug")</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>app.logger.warning("Mensaje a nivel warning")</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>app.logger.error("Mensaje a nivel error")</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return "&lt;h1&gt;Olee tu polla bro&lt;/h1&gt;"</span></p><h2><span style="font-weight:normal; font-style:normal">4. </span><span style="font-style:normal">MODULO REQUEST</span></h2><p><span>Podemos realizar peticiones por ejemplo:</span></p><p class="FencedCodepython"><span>app.logger.info(f"Entramos al paht {request.path}")</span></p><p><span>la respuesta del servidor será la siguiente</span></p><p class="FencedCodebash"><span>[2022-04-06 13:03:55,648] INFO in app: Entramos al paht /</span><br /><span>127.0.0.1 - - [06/Apr/2022 13:03:55] "GET / HTTP/1.1" 200 -</span></p><p><span>una respuesta de tipo GET a la ruta elegida en este caso, / .</span></p><h2><span style="font-weight:normal; font-style:normal">4. </span><span style="font-style:normal">ROUTING EN FLASK</span></h2><p><span>Vamos a seguir poniendo más paths, todos comienzan siempre con /loQueSea</span><br /><span>@app.route("/user")</span><br /><span>definimos debajo una nueva función para que haga lo que sea ese path.</span></p><p class="FencedCodepython"><span>@app.route("/saludar")</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><br /><span>def saludar():</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return "&lt;h1&gt;Salidos!!&lt;/h1&gt;"</span><br /><span>``</span><br /><span>También podemos recibir parámetros y estos tienen que especificar de que tipo son:</span></p><ol type="1" style="margin:0pt; padding-left:0pt"><li style="margin-left:31.35pt; padding-left:4.65pt"><span>String</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>Int</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>Float</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>path</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>uuid</span><br /><span>para ello quitando el String que es por defecto hay que especificarlo.</span></li></ol><p class="FencedCodepython"><span>@app.route("/saludar/&lt;nombre&gt;")</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><br /><span>def saludar(nombre):</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return f"&lt;h1&gt;Salidos!!{nombre}&lt;/h1&gt;"</span></p><p><span>le pasamos el parámetro nombre y nos vamos a la url si ponemos http://127.0.0.1:5000/saludar/Victor la respuesta que veremos será SALUDOS!! VICTOR</span><br /><span>Si le pasamos un Int como parámetro tendremos esto:</span></p><p class="FencedCodepython"><span>@app.route('/edad/&lt;int:edad&gt;')</span><br /><span>def muestra_edad(edad):</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return f"&lt;h1&gt;Hola, tienes {edad} años, gilipollas&lt;/h1&gt;"</span></p><p><span>si le ponemos /edad/40 en el navegador nos devolvera: Hola, tienes 40 años, gilipollas</span><br /><span>Con el valor de las variables que le pasamos podemos hacer de todo como cualquier variable en python nombre.upper para mayúsculas, edad + 1 para hacer operaciones aritméticas etc.</span></p><h2><span style="font-weight:normal; font-style:normal">5. </span><span style="font-style:normal">PETICIONES GET Y POST CON INSOMNIA REST O POSTMAN</span></h2><ol type="1" style="margin:0pt; padding-left:0pt"><li style="margin-left:31.35pt; padding-left:4.65pt"><span>GET</span><br /><span>El método GET</span><span style="-aw-import:spaces">&#xa0; </span><span>solicita una representación de un recurso específico. Las peticiones que usan el método GET sólo deben recuperar datos.</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>HEAD</span><br /><span>El método HEAD pide una respuesta idéntica a la de una petición GET, pero sin el cuerpo de la respuesta.</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>POST</span><br /><span>El método POST se utiliza para enviar una entidad a un recurso en específico, causando a menudo un cambio en el estado o efectos secundarios en el servidor.</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>PUT</span><br /><span>El modo PUT reemplaza todas las representaciones actuales del recurso de destino con la carga útil de la petición.</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>DELETE</span><br /><span>El método DELETE borra un recurso en específico.</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>CONNECT</span><br /><span>El método CONNECT establece un túnel hacia el servidor identificado por el recurso.</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>OPTIONS</span><br /><span>El método OPTIONS es utilizado para describir las opciones de comunicación para el recurso de destino.</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>TRACE</span><br /><span>El método TRACE</span><span style="-aw-import:spaces">&#xa0; </span><span>realiza una prueba de bucle de retorno de mensaje a lo largo de la ruta al recurso de destino.</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>PATCH</span><br /><span>El método PATCH</span><span style="-aw-import:spaces">&#xa0; </span><span>es utilizado para aplicar modificaciones parciales a un recurso.</span></li></ol><p><span>Vamos a descargar </span><a href="https://insomnia.rest" style="text-decoration:none"><span class="Hyperlink">insomnia rest Client</span></a><span> y elegimos nuestra instalación, yo mac en este caso.</span><br /><span>Arrancamos nuestro servidor en la aplicación, como siempre con, export FLASK_ENV=development y flask run.</span><br /><span>Creamos un new request en insomnia, le ponemos el nombre que queramos, podemos tener todo tipo de peticiones GET POST etc.</span><br /><span>Hacemos una petición de tipo GET a nuestra web htts://localhost:5000 y nos da varios datos en headers:</span><br /><span>Lo que resgresa:</span><br /><span>Server: Werkzeug/2.1.1 Python/3.8.9.</span><br /><span>Date: Sat, 09 Apr 2022 18:11:34 GMT.</span><br /><span>Content-Type: text/html; charset=utf-8.</span><br /><span>Content-Length: 26 //número de caracteres que estamos pidiendo</span><br /><span>En Timeline es el que más información te ofrece.</span><br /><span>GET / HTTP/1.1.</span></p><p class="Quote"><span style="font-style:normal">Host: 127.0.0.1:5000.</span><br /><span style="font-style:normal">User-Agent: insomnia/2022.2.1.</span><br /><span style="font-style:normal">Accept: </span><span>/</span><span style="font-style:normal">.</span><br /><span style="font-style:normal">El tipo de petición en este caso GET, a donde va dirigido en este caso a la URL de / de tipo http y la petición se ha hecho al localhost puerto 5000, usando como cliente (User-Agent): insomnia</span><br /><span style="font-style:normal">vemos la respuesta con el código de estado 200:</span><br /><span style="font-style:normal">HTTP/1.1 200 OK</span><br /><span style="font-style:normal">Método POST</span><br /><span style="font-style:normal">Si por ejemplo tenemos este código en una route del path:</span></p><p class="FencedCodepython"><span>@app.route("/mostrar/&lt;nombre&gt;")</span><br /><span>def mostrar_nombre(nombre):</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return f"Su nombre es {nombre}"</span><span style="-aw-import:spaces">&#xa0;&#xa0; </span></p><p><span>Si hacemos una petición por el método POST, nos saldrá error ya que hay que programar que pueda recibir tanto GET como POST</span></p><p class="FencedCodepython"><span>@app.route("/mostrar/&lt;nombre&gt;", methods["GET", "POST"])</span><br /><span>def mostrar_nombre(nombre):</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return f"Su nombre es {nombre}"</span><span style="-aw-import:spaces">&#xa0;&#xa0; </span></p><p><span>Ahora si vamos a insomnia y le ponemos el método POST nos devuelve la página:</span><br /><span>POST /mostrar/victor HTTP/1.1</span><br /><span>Host: 127.0.0.1:5000</span><br /><span>User-Agent: insomnia/2022.2.1</span><br /><span>Accept: </span><span style="font-style:italic">/</span><br /><span>Content-Length: 0</span><br /><span>ya que le hemos implementado que contenga los dos methods.</span><br /><span>GET para recuperar info del servidor</span><br /><span>POST para enviar info al servidor</span><br /><span>Es lo que usaremos más adelante para enviar y recibir peticiones de nuestra aplicación.</span></p><h2><span style="font-weight:normal; font-style:normal">6. </span><span style="font-style:normal">TEMPLATES</span></h2><p><span>Los templates en flask se usan con Jinja para realizar plantillas de html para saber más sobre jinja </span><a href="https://jinja.palletsprojects.com/en/3.1.x/" style="text-decoration:none"><span class="Hyperlink">PULSA AQUÍ</span></a><span>.</span><br /><span>Para ello vamos a importar rendering_templates que en vez de lleavr una cadena como hasta ahora, traeremos un documento html.</span><br /><span>En la carpeta de nuestro proyecto crearemos una carpeta llamada templates.</span><br /><span>dentro de esta carpeta creamos nuestro archivo html en este caso lo llamamos mostrar.html como la función anterior.</span><br /><span>Por el otro lado en la función lo vamos a dejar de esta manera:</span></p><p class="FencedCodepython"><span>@app.route('/mostrar/&lt;nombre&gt;', methods=['GET', 'POST'])</span><br /><span>def mostrar_nombre(nombre):</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return render_template('mostrar.html', nombre_llave=nombre)</span></p><p><span>render_template = es para que flask busque en la carpeta templates el archivo html en este caso 'mostrar.html'</span><br /><span>render lleva dos parámetros el archivo y la variable quye queremos mostrar nombre_llave es la variable del archivo html y el otro nombre es el del archivo app.py, que por convención sería el mismo nombre pero para aclararnos ahora le ponemos nombrellave</span><br /><span>el html quedaría tal que así:</span></p><p class="FencedCodehtml"><span>&lt;!DOCTYPE html&gt;</span><br /><span>&lt;html lang="en"&gt;</span><br /><span>&lt;head&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;meta charset="UTF-8"&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;title&gt;mostrar nombre&lt;/title&gt;</span><br /><span>&lt;/head&gt;</span><br /><span>&lt;body&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;h1&gt;MOSTRAR VALORES &lt;/h1&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;p&gt;Tu nombre es: {{nombre_llave}}&lt;/p&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;h1&gt;{{nombre_llave}}&lt;/h1&gt;</span><br /><span>&lt;/body&gt;</span><br /><span>&lt;/html&gt;</span><br /><span style="-aw-import:ignore">&#xa0;</span></p><p><span>como vemos le pasamos la variable entre dos llaves {{nombre_llave}}, así que en el navegador le pasamos la url localhost:5000/mostrar/victor y nos mostrará el resultado.</span></p><h2><span style="font-weight:normal; font-style:normal">7. </span><span style="font-style:normal">URL BUILDING</span></h2><p><span>Redireccionamientos de urls.</span></p><p class="FencedCodepython"><span>@app.route('/redireccionar')</span><br /><span>def redireccionar():</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return redirect(url_for('inicio'))</span></p><p><span>Ponemos una nueva route llamada /redireccionar, para ello definimos la función con un return que nos devuelve el método redirect para ello importamos</span></p><p class="FencedCodepython"><span>from werkzeug.utils import redirect </span></p><p><span>y luego con el método url_for de la biblio de flask le damos el nombre de la función a la que queremos redireccionar 'inicio' solo el nombre sin parétesis.</span><br /><span>Volvemos a nuestro html y le ponemos un link para redireccionar a / inicio:</span></p><p class="FencedCodehtml"><span style="-aw-import:spaces">&#xa0;</span><span>&lt;div&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>&lt;a href="/"&gt;INICIO&lt;/a&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;/div&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><br /><span> &lt;div&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>&lt;a href="{{url_for('inicio')}}"&gt;INICIO&lt;/a&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;/div&gt;</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><br /><span>&lt;div&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>&lt;a href="{{url_for('mostrar', edad=30)}}"&gt;INICIO&lt;/a&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;/div&gt;</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span></p><p><span>De esta manera ya tendríamos el redireccionamiento hecho, una vez que pulsamos el link nos lleva a donde le digamos.</span><br /><span>Podríamos realizar la misma función con url_for redireccionando directamente a la función inicio.</span></p><h2><span style="font-weight:normal; font-style:normal">8. </span><span style="font-style:normal">MANEJO DE ERRORES</span></h2><p><span>Para esto en Flask tenemos el método abort:</span></p><p class="FencedCodepython"><span>@app.route('/salir')</span><br /><span>def salir():</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return abort(404)</span></p><p><span>Si vamos a /salir nos da not found, página no encontrada.</span><br /><span>La podemos personalizar con un template en html.</span></p><p class="FencedCodehtml"><span>&lt;!DOCTYPE html&gt;</span><br /><span>&lt;html lang="en"&gt;</span><br /><span>&lt;head&gt;</span><br /><span>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;title&gt;ERROR 404&lt;/title&gt;</span><br /><span>&lt;/head&gt;</span><br /><span>&lt;body&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>error 404</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;div&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>{{error}}</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;/div&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;div&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>&lt;a href="{{url_for('redireccionar')}}"&gt;INICIO&lt;/a&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;/div&gt;</span><br /><span>&lt;/body&gt;</span><br /><span>&lt;/html&gt;</span></p><p class="FencedCodepython"><span>@app.errorhandler(404)</span><br /><span>def pagina_no_encontrada(error):</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return render_template('error404.html', error=error), error</span></p><p><span>En python podemos regresar varios valores sin paréntesis de ahi el , error.</span><br /><span>Si accedemos a /error nos da como ya es sabido nuestro error 404 not found, podemos poner el enlace al inicio debajo.</span></p><h2><span style="font-weight:normal; font-style:normal">9. </span><span style="font-style:normal">USO DE JSON Y FLASK</span></h2><p><span>Sobre las respuestas en Flask podemos responder con un objeto, con un String o con un diccionario.</span><br /><span>Con un dic en Flask directamente se hace con jsonify, esto es responder con respuestas de tipo json, que es lo más común.</span><br /><span>Esto es lo que se conoce con REST representation state transfer, esta respuesta de tipo json la van a consumir otros sistemas, y en particular frameworks de tipo front end como angular, React o VueJs, cualquiera de estos puede consumir esta info de tipo json.</span><br /><span>Por lo que vamos a crear desde Flask es nuestro back-end, por lo que hay que definir nuestros paths de una manera, /api (aplication normal interface)</span></p><p class="FencedCodepython"><span>@app.route("/api/mostrar/&lt;nombre&gt;", ,methods=['GET', POST])</span><br /><span>def mostrar_json(nombre):</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>valores = {'nombre': nombre, 'metodo_http': request.method}</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><br /><span style="-aw-import:spaces">&#xa0; </span><span>return valores</span><span style="-aw-import:spaces">&#xa0; </span></p><p><span>JSON (JavaScrip Object Notation) es texto escrito en json y debe de seguir ciertas reglas para responder en json y no en html.</span><br /><span>llaves clave:valor = {"name" : "John"} // los objetos en JavaScript usan llaves.</span><br /><span>Podemos usar todo tipo de Values:</span></p><ol type="1" style="margin:0pt; padding-left:0pt"><li style="margin-left:31.35pt; padding-left:4.65pt"><span>String</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>number</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>objet (JSON objets)</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>arrays</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>boolean</span></li><li style="margin-left:31.35pt; padding-left:4.65pt"><span>null</span></li></ol><p><span>Ejemplo:</span></p><p class="FencedCodejavaScript"><span>var person = {name : "John", age: 31, city: "EEUU"};</span></p><p><span>Del route /api/mostrar/&lt;nombre&gt; nos da el siguiente json:</span></p><p class="FencedCodejson"><span>{</span><br /><span style="-aw-import:spaces">&#xa0; </span><span>"metodo_http": "GET", </span><br /><span style="-aw-import:spaces">&#xa0; </span><span>"nombre": "victor"</span><br /><span>}</span></p><p><span>Le podemos dar methods de GET o POST o lo que veamos.</span></p><h1><span style="font-weight:normal">10. **SESIONES EN FLASK</span></h1><p><span>COOKIES es un archivo que se almacena en el servidor del lado del cliente y que contiene cierta información en forma de llave-valor</span><br /><span>y nos va dejar almacenar esa información durante dirferentes peticiones.</span><br /><span>Concepto de sesiones en flask:ç</span><br /><span>vamos a crear una variable secreta a través de app.secret_key por lo que será más seguro ya que la cookie podrá ser leida pero no modificada.</span><br /><span>vamos a app.py:</span></p><p class="FencedCodepython"><span>app.secret_key = 'mi_llave_secreta'</span><br /><br /><span>def inicio():</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>if 'username' in session:</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>return 'El user ya hizo loggin'</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return 'No ha hecho loggin'</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span></p><p><span>Así cuando vamos al path de inicio nos dice que el user no ha hecho loggin</span><br /><span>por lo que vamos a agregar el path de loggin y realizar un formulario en un nuevo template de html</span></p><p class="FencedCodepython"><span>@app.route('login')</span><br /><span>def login():</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return render_template(login.html)</span></p><p class="FencedCodehtml"><span>&lt;!DOCTYPE html&gt;</span><br /><span>&lt;html lang="en"&gt;</span><br /><span>&lt;head&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;meta charset="UTF-8"&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;title&gt;Login&lt;/title&gt;</span><br /><span>&lt;/head&gt;</span><br /><span>&lt;body&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;h1&gt;LOGIN&lt;/h1&gt;</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>&lt;form action=""&gt;&lt;/form&gt;</span><br /><span>&lt;/body&gt;</span><br /><span>&lt;/html&gt;</span></p><p><span>Nos quedaría un formulario para hacer login.</span><br /><span>Vamos a procesar esas peticiones de tipo POST ya que solicita al servidor que valide el usuario y contraseña:</span></p><p class="FencedCodepython"><span>@app.route("/", methods=['GET', 'POST'])</span><br /><span>def inicio():</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>if 'username' in session:</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>return f'El user {session["username"]} ya hizo loggin'</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return 'No ha hecho loggin'</span><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><br /><span style="-aw-import:spaces">&#xa0;&#xa0; </span><br /><br /><span>@app.route('/login', methods=['GET', 'POST'])</span><br /><span>def login():</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span># no se va a validar el user</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>if request.method == 'POST':</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>session['username'] = request.form['username']</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span># agregamos el usuario a la seession, sería como poner</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span># usuario = request.form['username'] (form es nuestro formulario)</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span># session['username'] = usuario</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>return redirect(url_for('inicio'))</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return render_template('login.html')</span></p><p><span>Aquí saldría el usuario ya ha hecho login, ya que se ha rellenado el form del login.html, y se ha validado por la funcion login, remirtiendote a la pagina inicio con redirect, o donde quieras.</span><br /><span>Arriba con el session["username"] nos da el nombre que pongamso en el formulario de login.</span></p><h1><span style="font-weight:normal">11. </span><span>ELIMINAR USUARIO DE LA SESIÓN.</span></h1><p><span>Es muy facil con session.pop():</span></p><p class="FencedCodepython"><span>@app.route('/logout')</span><br /><span>def logout():</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>session.pop('username')</span><br /><span style="-aw-import:spaces">&#xa0;&#xa0;&#xa0; </span><span>return redirect(url_for('inicio'))</span><span style="-aw-import:spaces">&#xa0; </span></p><p><span>Con pop lo saca de la session y con redirect lo vuelve a mandar inicio o donde quieras.</span></p></div></body></html>